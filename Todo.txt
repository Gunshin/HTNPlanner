

- add values to planneractionnode output

- :values does not take into account more than one value, and the values specific type currently

- values cannot have 2 seperate values existing in the same evaluation node hierarchy eg:
	(> (~count) (~arc))
	must ignore this and look for other evaluations
	
- must add comparisons for values eg.
	(and
		(< (has ?item) 20) ;; <<<< must be evaluated first
		(== (~count) 10)
	)



>=
>
<
<=
==



+
-
*
/




=	assign
increase
decrease


(and
	(> (~count) 0)
	(< (~count) (+ (20) (10)))
)

0 < ~count < 30

(or
	(and
		(> (~count) 0)
		(< (~count) (+ (20) (10)))
	)
	(and
		(> (~count) 50)
		(< (~count) (- (70) (10)))
	)
)
0 < ~count < 30
50 < ~count < 70

must evaluate any nodes contained within this node, which do not include our target value eg. '~count'

must add support for multiple value evaluation eg:
	(== (~count) (* 2 (~arc)))
	(< (~count) (~arc))

should i seperate the evaluation to allow me to verify whether the non value preconditions are allowed first? ----------------------------------------------

should i make the sets global and not per function? --------------------------------------------------------------------------------------------------------

Needs to be a distinction between 'or' and 'and'
	- and must return an array containing an range from a lower bound to an upper bound and/or a series of equivalence functions
	
	- or must concat all arrays from children. It does not form ranges of values, or look at equivalence functions. only concat.

and:
	- returns an array of values
		- could be a range from min to max if children are greater/less thans
		- could be values coming from an 'or' or multiple equivalent nodes
		eg.:
			(and
				(> (~count) 0)
				(< (~count) (+ (20) (10)))
			)
			gives:
				[1, ..., 29]
		eg.
			(or
				(and
					(< (has ?item) 20) ;; <<<< must be evaluated first
					(== (~count) 10)
				)
				(and
					(> (has ?item) 20)
					(== (~count) 50)
				)
				(and
					(> (~count) 0)
					(< (~count) 5)
				)
			)
			gives: has ?item == 10
				[10, 1, ..., 4]
			gives: has ?item == 25
				[50, 1, ..., 4]


or:
	- concats any arrays passed back up by its children, and returns it
		(or
			(== (~count) (* 2 (inventory_count)))
			(and
				(<= (~count) 10)
				(> (~count) 0)
			)
			(and
				(> (~count) 50)
				(< (~count) 60)
			)
		)
		gives:
			[~count = 2 * ~arc, 1, ..., 10, 51, ..., 59]

			
			